package node

import (
	"github.com/gomarkdown/markdown/ast"
)

func ConvertDocNodes2MD(nodes []*DocNode) ([]byte, error) {
	root := &ast.Document{}
	serializerDocNodeContent(root, nodes)
	return nil, nil
}

func serializerDocNodeInline(parent ast.Node, nodes []*DocNode) {
	for _, node := range nodes {
		switch node.Type {
		case "text", "image":
			h := serializerDocNode[node.Type]
			n := h(node)
			serializerDocNodeMark(n, node.Mark)
			ast.AppendChild(parent, n)
		}
	}
}

func serializerDocNodeContent(parent ast.Node, nodes []*DocNode) {
	for _, node := range nodes {
		if h, ok := serializerDocNode[node.Type]; ok {
			ast.AppendChild(parent, h(node))
		}
	}
}

func serializerDocNodeMark(parent ast.Node, marks []*DocNode) {
	for _, v := range marks {
		switch v.Type {
		case "link":
			n := &ast.Link{}
			if href := v.LookupAttrString("href"); href != "" {
				n.Destination = []byte(href)
			}
			if title := v.LookupAttrString("title"); title != "" {
				n.Title = []byte(title)
			}
			ast.AppendChild(parent, n)
		case "strong":
			n := &ast.Strong{}
			ast.AppendChild(parent, n)
		case "em":
			n := &ast.Emph{}
			ast.AppendChild(parent, n)
		case "code":
			n := &ast.Code{}
			ast.AppendChild(parent, n)
		}
	}
}

type serializerfunc func(c *DocNode) ast.Node

var serializerDocNode = map[string]serializerfunc{

	"text": func(c *DocNode) ast.Node {
		return &ast.Text{Leaf: ast.Leaf{Literal: []byte(c.Text)}}
	},

	"image": func(c *DocNode) ast.Node {
		return &ast.Image{
			Destination: []byte(c.LookupAttrString("src")),
			Title: func() []byte {
				if title := c.LookupAttrString("title"); title != "" {
					return []byte(title)
				}
				return nil
			}(),
		}
	},

	"hard_break": func(c *DocNode) ast.Node {
		return &ast.Hardbreak{}
	},

	"blockquote": func(c *DocNode) ast.Node {
		n := &ast.BlockQuote{}
		m.renderContent(n, c.Content)
		return n
	},

	"code_block": func(c *DocNode) ast.Node {
		return &ast.CodeBlock{
			Leaf: ast.Leaf{Literal: []byte(c.Text)},
			Info: func() []byte {
				if l := c.LookupAttrString("language"); l != "" {
					return []byte(l)
				}
				return nil
			}(),
		}
	},

	"code": func(c *DocNode) ast.Node {
		return &ast.Code{
			Leaf: ast.Leaf{Literal: []byte(c.Text)},
		}
	},

	"heading": func(c *DocNode) ast.Node {
		n := &ast.Heading{
			Level: int(c.LookupAttrNumber("level")),
		}
		m.renderInline(n, c.Content)
		return n
	},

	"horizontal_rule": func(c *DocNode) ast.Node {
		return &ast.HorizontalRule{}
	},

	"paragraph": func(c *DocNode) ast.Node {
		n := &ast.Paragraph{}
		m.renderInline(n, c.Content)
		return n
	},

	"bullet_list": func(c *DocNode) ast.Node {
		n := &ast.List{
			ListFlags:  ast.ListTypeTerm,
			BulletChar: byte('-'),
		}
		m.renderContent(n, c.Content)
		return n
	},

	"ordered_list": func(c *DocNode) ast.Node {
		n := &ast.List{
			ListFlags: ast.ListTypeOrdered,
			Delimiter: byte('.'),
		}
		m.renderContent(n, c.Content)
		return n
	},

	"list_item": func(c *DocNode) ast.Node {
		n := &ast.ListItem{}
		m.renderContent(n, c.Content)
		return n
	},
}
